#' Perform statistical testing and rank genes
#'
#' This function performs statistical testing of all genes in a fitness coefficient object generated by the fitCof function.
#' By default, the function performs a t.test, followed by Benjamini-Hochberg correction for multiple testing (FDR). Other available tests are "wilcox.test" and "nonlog.t.test"). And method accepted by the R p.adjust function can be used for multiple testing correction.
#'
#' @param fitCofList A fitness coefficient object generated by the fitCof function.
#' @param test The type of statistical test to use.
#' @param correction The type of correction for multiple testing to use.
#' @param pcut Cutoff p-value to be included in output (default = 1, will include all genes).
#' @param toplist If specified, the list is restricted to this number of genes. If specified as FALSE, the returned object will not be sorted, but will retain its original order.
#'
#' @return Returns a list of statistical tests for genes, ranked by p-value.
#' 
#' @export
rankByP = function(fitCofTable, test = "t.test", correction = "BH", pcut = 1, toplist = NULL) {
    testTable = matrix(NA,nrow(fitCofTable),4)
    colnames(testTable) = c("Average","St.dev","p-value","Corrected p-value")
    for (g in 1:nrow(fitCofTable)) {
        testTable[g,1] = mean(fitCofTable[g,])
        testTable[g,2] = sqrt(var(fitCofTable[g,]))
        if (test == "t.test") {
            testTable[g,3] = t.test(fitCofTable[g,])$p.value
            testTable[g,4] = 1
        }
        if (test == "wilcox.test") {
            testTable[g,3] = wilcox.test(fitCofTable[g,])$p.value
            testTable[g,4] = 1
        }
        if (test == "nonlog.t.test") {
            testTable[g,3] = t.test(2^fitCofTable[g,], mu = 1)$p.value
            testTable[g,4] = 1
        }
    }
    if (correction == "BHvar") {
        ranked = rank(testTable[,3])
        for (g in 1:nrow(fitCofTable)) {
            testTable[g,4] = (testTable[g,3] * nrow(fitCofTable)) / ranked[g]
        }
    } else {
        testTable[,4] = p.adjust(testTable[,3], correction)
    }
    
    row.names(testTable) = row.names(fitCofTable)

    sortedTable = testTable[order(testTable[,3]),]
    if (min(sortedTable[,4]) <= pcut) {
        if (is.null(toplist)) {
            return(sortedTable[sortedTable[,4] <= pcut,])
        } else {
            if ((toplist == FALSE) | (toplist == 0)) {
                return(testTable)
            } else {
                return(sortedTable[sortedTable[,4] <= pcut,][1:toplist,])
            }
        }
    } else {
        stop("No values smaller than p-value cutoff to return!")
    }
}
