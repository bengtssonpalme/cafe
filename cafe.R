#### Functions: ####
## loadData = function(inputFileName)
# Load data into R from an Inseq counts file

## fitCof = function(testCondition, control)
# Generate fitness coefficients for two different conditions. See possible conditions by typing "treatments"

## fitCofComp = function(control, treatmentList)
# Generate fitness coefficients for all conditions (treatmentList) compared to a control condition. See possible conditions by typing "treatments"

## rankByP = function(fitCofTable, test = "t.test", correction = "BH", pcut = P-VALUE, toplist = NUMBER)
# Generate a ranked list of genes from a table of fitness co-efficients generated by fitCof (above). Can be filtered by p-value cutoff or number of hits (toplist).




## sizeNormalize = function(countDataTable = "", undefCountTable = "")
# Normalizes each count by the total number of mapped reads (no need to use this directly)

## generatePseudoCount = function(countDataTable = NULL, undefCountTable = NULL, controlDataTable = NULL, controlUndefTable = NULL, includeAdapt = FALSE)
# Generates a suitable pseudo-count number. No need to use this directly




loadData = function(inputFileName = "") {
    if (inputFileName == "") {
        ## Bring up file name dialog...
        inputFileName = "all_rep_inseq.txt"
    }
    countData <<- read.table(inputFileName, row.names = 1, header = T, quote = "", sep = "\t")
    countData <<- within(countData, rm("X"))
    undefCounts <<- countData["undef",]
    unmappedCounts <<- countData["unmapped",]
    countData <<- countData[1:(nrow(countData)-2),]
    countMatrix <<- as.matrix(countData)
    geneNames <<- row.names(countData)
    sampleNames <<- colnames(countData)
    treatmentClasses <<- factor(sub("_[0-9]+$","",sampleNames))
    treatments <<- grep("Adapt",levels(treatmentClasses),ignore.case = TRUE, invert = TRUE, value = TRUE)
    #replicates = factor(sub(".*(_[0-9]+)$","\1",sampleNames))
}

sizeNormalize = function(countDataTable = NULL, undefCountTable = NULL, returnUndef = FALSE) {
    if (is.null(countDataTable)) {
        countDataTable = countData
    }
    if (is.null(undefCountTable)) {
        undefCountTable = undefCounts
    }
    if (returnUndef == FALSE) {
        totalCounts = colSums(as.matrix(countDataTable)) + as.vector(undefCountTable)
        normalizedCountTable = t(t(as.matrix(countDataTable)) / as.numeric(totalCounts))
        return(normalizedCountTable)
    } else {
        totalCounts = colSums(as.matrix(countDataTable)) + as.vector(undefCountTable)
        normalizedCountTable = t(t(as.vector(undefCountTable)) / as.numeric(totalCounts))
        return(normalizedCountTable)
    }
}

generatePseudoCount = function(countDataTable = NULL, undefCountTable = NULL, controlDataTable = NULL, controlUndefTable = NULL, includeAdapt = FALSE) {
    if (is.null(countDataTable)) {
        countDataTable = countData
    }
    if (is.null(undefCountTable)) {
        undefCountTable = undefCounts
    }
    if (is.null(controlDataTable) || is.null(controlUndefTable)) {
        if (includeAdapt) {
            totalCounts = colSums(as.matrix(countDataTable)) + as.vector(undefCountTable)
            pseudoCount = 1 / min(as.numeric(totalCounts + 1))
        } else {
            totalCounts = colSums(as.matrix(countDataTable[,grep("Adapt",sampleNames,ignore.case = T, invert = T)])) + as.vector(undefCountTable[grep("Adapt",sampleNames,ignore.case = T, invert = T)])
            pseudoCount = 1 / min(as.numeric(totalCounts + 1))
        }
    } else {
        allData = cbind(as.matrix(countDataTable),as.matrix(controlDataTable))
        undefData = c(as.numeric(undefCountTable),as.numeric(controlUndefTable))
        totalCounts = colSums(as.matrix(allData)) + as.vector(undefData)
        pseudoCount = 1 / min(as.numeric(totalCounts + 1))
    }
    return(pseudoCount)
}

fitCof = function(testCondition, control, dataTable = NULL, undefCountTable = NULL, correction = "undefined") {
    if (is.null(dataTable)) {
        dataTable = countData
    }
    if (is.null(undefCountTable)) {
        undefCountTable = undefCounts
    }
    testData = dataTable[,grep(paste("^",testCondition,"_[0-9]+$",sep = ""),sampleNames)]
    controlData = dataTable[,grep(paste("^",control,"_[0-9]+$",sep = ""),sampleNames)]
    undefTest = undefCountTable[grep(paste("^",testCondition,"_[0-9]+$",sep = ""),sampleNames)]
    undefControl = undefCountTable[grep(paste("^",control,"_[0-9]+$",sep = ""),sampleNames)]
    pseudoCount = generatePseudoCount(testData, undefTest, controlData, undefControl)

    normData = sizeNormalize(dataTable, undefCountTable)

    totalCounts = colSums(as.matrix(countData)) + as.vector(undefCounts)
    normUndef = as.vector(undefCounts) / as.numeric(totalCounts)
    
    testData = normData[,grep(paste("^",testCondition,"_[0-9]+$",sep = ""),sampleNames)]
    controlData = normData[,grep(paste("^",control,"_[0-9]+$",sep = ""),sampleNames)]
    undefTest = normUndef[grep(paste("^",testCondition,"_[0-9]+$",sep = ""),sampleNames)]
    undefControl = normUndef[grep(paste("^",control,"_[0-9]+$",sep = ""),sampleNames)]

    testData = testData + pseudoCount
    controlData = controlData + pseudoCount

    #print(apply(testData,2,median))
    #print(apply(controlData,2,median))
    
    if (ncol(testData) != ncol(controlData)) {
        stop("Numbers of replicates does not match between conditions!")
    }
    fitCofs = matrix(0,nrow(controlData),ncol(controlData))
    for (r in 1:ncol(controlData)) {
        if (correction == "undefined") {
            fitCofs[,r] = ((as.numeric(testData[,r]) / as.numeric(controlData[,r])) / (as.numeric(undefTest[r]) / as.numeric(undefControl[r])))
        }
        if (correction == "median") {
            fitCofs[,r] = ((as.numeric(testData[,r]) / as.numeric(controlData[,r])) / (median(testData[,r]) / median(controlData[,r])))
        }
        if (correction == "none") {
            fitCofs[,r] = ((as.numeric(testData[,r]) / as.numeric(controlData[,r])))
        }
        #print(dim((as.numeric(testData[,r]) / as.numeric(controlData[,r]))))
        #print(dim((undefTest[r] / undefControl[r])))
        #print(median(testData[,r]))
        #print(median(controlData[,r]))
        #print(undefTest[r])
        #print(undefControl[r])
        
        #print(-log2(median(as.numeric(testData[,r]) / as.numeric(controlData[,r])) / (undefTest[r] / undefControl[r])))
    }
    row.names(fitCofs) = geneNames
    colnames(fitCofs) = colnames(testData)
    return(-log2(fitCofs))
}

fitCofComp = function(control, treatmentList, dataTable = NULL, undefCountTable = NULL, correction = "undefined") {
    if (is.null(dataTable)) {
        dataTable = countData
    }
    if (is.null(undefCountTable)) {
        undefCountTable = undefCounts
    }

    controlData = dataTable[,grep(paste("^",control,"_[0-9]+$",sep = ""),sampleNames)]
    fullCofTable = matrix(0,nrow(controlData),1)
    for (t in 1:length(treatmentList)) {
        testCondition = treatmentList[t]
        fitCofsTreatment = fitCof(testCondition, control, dataTable, undefCountTable, correction)
        fullCofTable = cbind(fullCofTable, fitCofsTreatment)
    }
    fullCofTable = fullCofTable[,-1]
    return(fullCofTable)
}

rankByP = function(fitCofTable, test = "t.test", correction = "BH", pcut = 1, toplist = NULL) {
    testTable = matrix(NA,nrow(fitCofTable),4)
    colnames(testTable) = c("Average","St.dev","p-value","Corrected p-value")
    for (g in 1:nrow(fitCofTable)) {
        testTable[g,1] = mean(fitCofTable[g,])
        testTable[g,2] = sqrt(var(fitCofTable[g,]))
        if (test == "t.test") {
            testTable[g,3] = t.test(fitCofTable[g,])$p.value
            testTable[g,4] = 1
        }
        if (test == "wilcox.test") {
            testTable[g,3] = wilcox.test(fitCofTable[g,])$p.value
            testTable[g,4] = 1
        }
        if (test == "nonlog.t.test") {
            testTable[g,3] = t.test(2^fitCofTable[g,], mu = 1)$p.value
            testTable[g,4] = 1
        }
    }
    if (correction == "BHvar") {
        ranked = rank(testTable[,3])
        for (g in 1:nrow(fitCofTable)) {
            testTable[g,4] = (testTable[g,3] * nrow(fitCofTable)) / ranked[g]
        }
    } else {
        testTable[,4] = p.adjust(testTable[,3], correction)
    }
    
    row.names(testTable) = row.names(fitCofTable)

    sortedTable = testTable[order(testTable[,3]),]
    if (min(sortedTable[,4]) <= pcut) {
        if (is.null(toplist)) {
            return(sortedTable[sortedTable[,4] <= pcut,])
        } else {
            if ((toplist == FALSE) | (toplist == 0)) {
                return(testTable)
            } else {
                return(sortedTable[sortedTable[,4] <= pcut,][1:toplist,])
            }
        }
    } else {
        stop("No values smaller than p-value cutoff to return!")
    }
}

upDown = function(testCondition, control, p = 0.05, dataTable = NULL, undefCountTable = NULL, correction = "undefined", drawPlot = FALSE) {
    if (is.null(dataTable)) {
        dataTable = countData
    }
    if (is.null(undefCountTable)) {
        undefCountTable = undefCounts
    }
    fitCofs = fitCof(testCondition,control, dataTable, undefCountTable, correction)
    rankedList = rankByP(fitCofs)
    if (drawPlot == TRUE) {
        plot(rankedList[,1], ylab = "Selection coefficient", main = paste(testCondition,"vs",control))
    }
    up = sum(rankedList[rankedList[,3] <= p,1] > 0)
    down = sum(rankedList[rankedList[,3] <= p,1] < 0)
    expected = floor(p * nrow(dataTable) / 2)
    return(c(up,down,expected))
}

generateGSC = function(file, columns = c(1,3), header = FALSE) {
    mappingTable = as.matrix(read.table(file, sep = "\t", quote = "", header = header))
    geneNames = unique(mappingTable[,columns[1]])
    pathways = unique(mappingTable[,columns[2]])
    pathwayList = list()
    #GSCobject = list()
    for (i in 1:nrow(mappingTable)) {
        gene = mappingTable[i,columns[1]]
        pathway = mappingTable[i,columns[2]]
        pathwayList[[`pathway`]] = c(pathwayList[[`pathway`]],as.character(gene))
    }
    #GSCobject$gsc = pathwayList
    #GSCobject$addinfo = "none"
    return(pathwayList)
}

genesetAnalysis = function(GSC, dataset, p = 0.05, test = "t.test", center = FALSE) {
  if (center == TRUE) {
    moddataset = dataset
    moddataset[,1] = dataset[,1] - mean(dataset[,1])
  } else {
    moddataset = dataset
  }
  row.names(moddataset) = sub(":.*","",row.names(moddataset))
  hist(moddataset[,1])
  pathways = names(GSC)
  returnList = matrix(0,length(pathways),6)
  row.names(returnList) = unlist(pathways)
  colnames(returnList) = c("Up","Down","Non-significant","Mean","p-value","adj.p")
  for (pn in 1:(length(pathways))) {
    pathwayname = pathways[pn]
    genelist = as.vector(unlist((GSC[[pathwayname]])))
    if (length(genelist) < 2) {
      next()
    }
    pathwaygenes = moddataset[genelist,]
    signGenes = pathwaygenes[pathwaygenes[,3] <= p,]
    if (length(row.names(signGenes)) < 1) {
      genesUp = 0
      genesDown = 0
      genesNS = length(genelist)
      pval = NA
      estval = NA
    } else {
      genesUp = sum(signGenes[,1] > 0)
      genesDown = sum(signGenes[,1] < 0)
      genesNS = length(genelist) - genesUp - genesDown
      if (test == "t.test") {
        testResult = try(t.test(signGenes[,1]), silent = TRUE)
        if (class(testResult) == "try-error") {
            pval = NA
            estval = NA
        } else {
            pval = testResult$p.value
            estval = testResult$estimate
        }
      }
      if (test == "wilcox") {
        testResult = wilcox.test(signGenes[,1])
        pval = testResult$p.value
        estval = abs(genesUp - genesDown)
      }
    }
    returnList[pn,] = c(genesUp,genesDown,genesNS,estval,pval,pval)
  }
  returnList = returnList[returnList[,1] + returnList[,2] + returnList[,3] > 0,]
  returnList[,6] = p.adjust(returnList[,5], method = 'BH')
  return(returnList)
}

boxplotFCs = function(fitCofComp, gene) {
    boxplot(fitCofComp[grep(gene,row.names(fitCofComp)),] ~ factor(sub("_[1-9]$","",colnames(fitCofComp))), las = 2, cex.lab = 0.8, cex.axis = 0.6, xlab = "", ylab = "Fitness coefficient", range = 0, main = grep(gene,row.names(fitCofComp), value = TRUE))
}

plotFCs = function(fitCofList, colorList = NULL, conditionA = "Fitness coefficient", conditionB = "Fitness coefficient", lim = c(-11,11)) {
    fc_ctrl = fitCofList[[1]]
    if (max(fc_ctrl[,3]) > 1 || min (fc_ctrl[,3]) < 0) {
        runRanks = TRUE
    } else {
        runRanks = FALSE
    }
    if (is.null(colorList)) {
        colorList = 1:length(fitCofList)
    }

    if (runRanks) {
        fc_ctrl = rankByP(fitCofList[[1]],toplist = FALSE)
    }
    
    plot(fc_ctrl[,1], fc_ctrl[,1], type = "n", ylim = lim, xlim = lim, xlab = conditionA, ylab = conditionB)
    for (i in 2:length(fitCofList)) {
        if (runRanks) {
            fc_test = rankByP(fitCofList[[i]],toplist = FALSE)
        } else {
            fc_test = fitCofList[[i]]
        }
        points(fc_ctrl[,1], fc_test[,1], col = colorList[i-1], cex = 0.2)
    }
    for (i in 2:length(fitCofList)) {
        if (runRanks) {
            fc_test = rankByP(fitCofList[[i]],toplist = FALSE)
        } else {
            fc_test = fitCofList[[i]]
        }
        points(fc_ctrl[fc_test[,3] < 0.05,1], fc_test[fc_test[,3] < 0.05,1], col = colorList[i-1], cex = 0.4)
    }
    for (i in 2:length(fitCofList)) {
        xlm = lm(fitCofList[[i]][,1] ~ fc_ctrl[,1])
        abline(xlm, lty = 2, col = colorList[i-1])
    }
}
